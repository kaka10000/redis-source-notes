# Redis设计与实现(五): 事件

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
* 文件事件(file event)：Redis服务器通过套接字与客户端(或其他Redis服务器)进行连接，而文件事件是服务器对套接字操作的抽象。服务器与客户端(或其他服务器)的通信会产生相应的文件事件，而服务器通过监听并处理这些事件来完成一系列网络通信操作。
* 时间事件(time event)：Redis服务器中的一些操作(比如serverCron函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象

### 文件事件
1. Redis基于Reactor模式开发了自己的网络时间处理器，这个处理器被称为文件事件处理机(file event handler)：
* 文件事件处理器使用I/O多路复用(multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
* 当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时，与操作相对应的文件事件就会产生，这时，文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。
2. 文件事件处理器的四个组成部分：它们分别是套接字、I/O多路复用程序、文件事件分派器(dispatcher)，以及事件处理器
    <div align = "center">
    <img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" width="400" height="400" alt="文件事件处理器"/>
    </div>
    * 文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答(accept)、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件可能会并发地出现
    * I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字，I/O多路复用程序总是会将所有产生事件的套接字都放在一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字
    <div align = "center">
    <img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E9%98%9F%E5%88%97.png" width="400" height="400" alt="IO多路复用程序通过队列向文件事件分派器传送套接字"/>
    </div>
    * 文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器
3. Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，并且都实现了相同的API，所以I/O多路复用程序的底层实现可以是互换的。
4. I/O多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：
    * 当套接字变得可读时(客户端对套接字执行write或close操作)，或有新的可应答(acceptable)套接字出现时(客户端对服务器的监听套接字执行connect操作)，套接字产生AE_READABLE事件
    * 当套接字变得可写时(客户端对套接字执行read操作)，套接字产生AE_WRITABLE事件
注：I/O多路复用程序允许服务器同时监听套接字的AE_READABLE和AE_WWRITABLE事件，如果一个套接字同时产生两种事件，优先处理AE_READABLE事件，当读事件处理完后，再处理AE_WRITABLE事件
5. Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：
    * 为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器(具体实现为sys/socket.h/accept函数的包装)
    * 为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器(具体实现为unistd.h/read函数的包装)
    * 为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器(具体实现为unistd.h/write函数的包装)
    * 当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器

#### 一次完整的客户端与服务器连接事件示例
* 假设一个Redis服务器正在运行，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器
* 如果这时有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求
* 之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行
* 执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复器相关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入套接字之后，服务器就会接触客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。

以上，即整个通信过程，以及通信时用到的事件处理器。
    <div align = "center">
        <img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" width="400" height="400" alt="客户端和服务器的通信过程"/>
    </div>

### 时间事件
1. Redis的时间事件分为以下两类：
    * 定时事件：让一段程序在执行的时间之后执行一次
    * 周期4xin性事件：让一段程序在每隔指定时间就执行一次
2. 一个时间事件主要由以下三个属性组成
    * id: 服务器为时间事件创建一个全局唯一ID(标识号)。ID号从小到大的顺序递增，新事件的ID号比旧事件的ID号要大
    * when: 毫秒精度的UNIX时间戳，记录了时间事件的到达(arrive)时间
    * timeProc: 时间处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。
3. 一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：
    * 如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在到达一次之后就会被删除，之后不再到达
    * 如果事件返回一个非AE_NOMORE的整数值，那么这个事件为周期性事件：当一个时间事件到达之后，服务器就会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间后再次到达，并以这种方式一直更新并运行下去。
4. 服务器将所有时间事件都放在一个无序链表中，每当时间时间执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器

#### 时间事件应用实例：serverCron函数
1. 持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：
    * 更新服务器的各类统计信息，比如时间、内存占用、数据库占用等情况
    * 清理数据库中过期键值对
    * 关闭和清理连接失效的客户端
    * 尝试进行AOF或RDB持久化
    * 如果服务器是主服务器，那么对从服务器进行定期同步
    * 如果处于集群模式，对集群进行定期同步和连接测试
2. Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。

### 事件的调度和执行
1. 因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，以及花多少时间来处理它们等等。事件的调度和执行由ae.c/aeProcessEvents函数负责，伪码如下：

    ```python
    def aeProcessEvents():
        # 获取到达时间离当前时间最接近的时间事件
        time_event = aeSearchNearestTimer()
        
        # 计算最接近的时间事件距离到达还有多少毫秒
        remaind_ms = time_event.when - unix_ts_now()
        
        # 如果事件已到达，那么remaind_ms的值可能为负，将其设为0
        if remaind_ms < 0
            remaind_ms = 0
        
        # 根据remaind_ms的值，创建timeval结构
        timeval = create_timeval_with_ms(remaind_ms)
        
        # 阻塞并等待文件事件发生，最大阻塞时间由传入的timeval结构决定
        # 如果remaind_ms的值为0，那么aeApiPoll调用会马上返回，不阻塞
        aeApiPoll(timeval)
        
        # 处理已发生的文件事件
        processFileEvents()
        
        # 处理所有已到达的时间事件
        processTimeEvents()
    ```
3. 从事件处理的角度来看，Redis服务器的运行流程可以用下图概况：
    <div align = "center">
        <img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" width="400" height="400" alt="服务器运行流程"/>
    </div>

4. 以下是事件的调度和执行规则：
    * aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询(忙等待)，也可以确保aeApiPoll函数不会阻塞过长时间
    * 因为文件事件是随机出现的，如果等待并处理完一次文件事件后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时，服务器就可以开始处理到达的时间事件了
    * 对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可能地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性
    * 因为时间事件在文件事件之后执行，并且事件不会出现抢占，所以时间事件的实际处理时间，通常比时间事件设定的到达时间稍晚一些
    


























    