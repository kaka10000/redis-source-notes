# Redis设计与实现(二)：对象

在前面第一部分，介绍了Redis用到的所有主要数据结构，比如简单动态字符串(SDS)、双端链表、字典、压缩列表、整数集合等。Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构构建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种前面所介绍到的数据结构。

Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数来实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库共享同一个对象来节约内存。

### 对象的类型与编码
1. Redis使用对象来表示数据库中的键和值，每次当在Redis的数据库中新创建一个键值对时，至少会创建两个对象，一个对象用作键值对的键(键对象)，另一个对象用作键值对的值(值对象)。
2. Redis中的每个对象都由一个`redisObject`结构表示，该结构中和保存数据有关的三个属性分别是type属性，encoding属性和ptr属性：

    ```cpp
    typedef struct redisObject{
        //类型
        unsigned type:4;
        //编码
        unsigned encoding:4;
        //指向底层实现数据结构的指针
        void *ptr;
        //...
    }robj;
    ```
3. 对象的type属性记录了对象的类型，这个类型可以是下表中的其中一个：
<table>
<tr>
<td> 类型常量 </td>
<td> 对象的名称 </td>
<td> TYPE命令的输出 </td>
</tr>
<tr>
<td> REDIS_STRING </td>
<td> 字符串对象 </td>
<td> "string" </td>
</tr>
<tr>
<td> REDIS_LIST </td>
<td> 列表对象 </td>
<td> "list" </td>
</tr>
<tr>
<td> REDIS_HASH </td>
<td> 哈希对象 </td>
<td> "hash" </td>
</tr>
<tr>
<td> REDIS_SET </td>
<td> 集合对象 </td>
<td> "set" </td>
</tr>
<tr>
<td> REDIS_ZSET </td>
<td> 有序集合对象 </td>
<td> "zset" </td>
</tr>
</table>

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象，列表对象，哈希对象，集合对象或者有序集合对象的其中一种。当我们对一个数据库键执行`TYPE`命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。
3. 对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。encoding属性记录了对象多使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。
4. 通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。

### 字符串对象
1. 字符串对象的编码可以是int、raw或者embstr
2. 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面(将void*转换为long)，并将字符串对象的编码设置为int
3. 如果字符串对象保存的是一个字符串值，并且这个字符串的长度大于39字节，那么字符串对象将使用给一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为raw
4. 如果字符串对象保存的是一个字符串值，并且这个字符串的长度小于等于39字节，那么字符串对象将使用embstr编码方式来保存这个字符串值
5. embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构。
6. int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象

### 列表对象
1. 列表对象的编码可以是ziplist或者linkedlist
2. ziplist编码的的列表对象使用给压缩列表作为底层实现，每个压缩列表节点(entry)保存了一个列表元素。
3. linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点(node)都保存了一个字符串对象，每个字符串对象都保存了一个列表元素
4. 当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：
    * 列表对象保存的所有字符串元素的长度都小于64字节
    * 列表对象保存的元素数量小于512个
    * 不能同时满足以上两个条件的列表对象需要使用linkedlist编码

### 哈希对象
1. 哈希对象的编码可以是ziplist或者hashtable
2. ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后在将保存了值的压缩列表节点推入到压缩列表的表尾，因此：
    * 保存了同一个键值对的节点总是紧挨在一起，保存键的节点在前，保存值的节点在后
    * 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象的键值对会被放在压缩列表的表尾方向
3. hashtable编码的哈希对象使用字典来作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存
    * 字典的每个键都是一个字符串对象，对象中保存了键值对的键
    * 字典的每个值都是一个字符串对象，对象中保存了键值对的值
4. 当哈希对象可以同时满足一下两个条件时，哈希对象使用ziplist编码：
    * 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
    * 哈希对象保存的键值对数量小于512个
    * 不能同时满足这两个条件的哈希对象需要使用hashtable编码

### 集合对象
1. 集合对象的编码可以是intset或者hashtable
2. intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面
3. hashtable编码的集合对象使用字典作为底层实现，字典的每一个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被置为NULL
4. 当集合对象可以同时满足以下两个条件是，对象使用intset编码：
    * 集合对象保存的所有元素都是整数值
    * 集合对象保存的元素个数不超过512个
    * 不能同时满足这两个条件的集合对象需要使用hashtable编码

### 有序集合对象
1. 有序集合对象的编码可以使ziplist或者skiplist
2. ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员(member)，而第二个元素则保存元素的分值(score)。压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的位置，而分值较大的元素则被放置在靠近表尾的位置
3. skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：

    ```cpp
    typedef struct zset{
        zskiplist *zsl;
        dict *dict;
    }zset;
    ```
* zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作
* zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用O(1)复杂度查找给定成员的分值
4. 注意：虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但是这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。
5. 当有序集合对象可以同时满足以下两种条件时，对象使用ziplist编码
    * 有序集合保存的元素数量小于128个
    * 有序集合保存的所有元素的长度都小于64字节
    * 不能同时满足以上两个条件的有序集合对象将使用skiplist编码

### 类型检查
1. Redis中由于操作键的命令基本上可以分为两种：一是该命令可以对任何类型的键使用。二是该命令只能对特定的键使用
2. 为了确保只有指定类型的键可以执行某些特定的命令，在指向一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。类型检查是通过redisObject结构的type属性来实现的：
    * 在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就会对键执行指定的命令。
    * 否则，服务器拒绝执行命令，并向客户端返回一个类型错误

### 内存回收和对象共享
1. Redis在自己的对象系统中构建了一个引用计数(reference counting)技术实现内存回收机制。通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。
2. 每个对象的引用计数信息由redisObject结构的reference属性记录。
3. 对象的引用计数信息会随着对象的使用状态而不断变化
    * 当创建一个新对象时，引用计数的值被初始化为1
    * 当对象被一个新程序使用时，它的引用计数值会被增一
    * 当对象不再被一个程序使用时，它的引用计数值会被减一
    * 当对象的引用计数变为0时，对象所占用的内存会被释放
4. 除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：
    * 1.将数据库键的值指针指向一个现有的值对象
    * 2.将被共享的值对象的引用计数增一
5. 目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象

### 对象的空转时长
1. 除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObejct结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间。
                                    



