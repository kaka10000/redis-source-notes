# Redis设计与实现(六): 服务器和客户端

Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复

### 客户端
1. Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历clients链表来完成：

    ```cpp
    struct redisServer{
        //...
        //一个链表，保存了所有客户端状态
        list *clients;
    }
    ```
示例如下：

    <div align = "center">
    <img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/clients%E9%93%BE%E8%A1%A8.png" width="400" height="400" alt="clients链表"/>
    </div>
    
2. 客户端状态包含的属性可以分为两类：
    * 一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性
    * 另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等

```cpp
typedef struct redisClient{
    //...
    int fd;
    
    //客户端的名字记录在该属性中
    robj *name;
    
    //客户端的flags属性使用不同的标志来表示客户端的角色，以及客户端当前所处的状态
    int flags;
    
    //输入缓冲区记录了客户端发送的命令请求，大小不能超过1GB
    sds querybuf;
    
    //argv和argc分别记录命令的参数和参数个数，
    //而cmd属性则记录了客户端要执行命令的实现函数,cmd是一个字典，
    //键保存了命令的名字，值为对应的redisCommand结构，其中保存了命令的实现函数
    robj **argv;
    int argc;
    struct redisCommand *cmd;
    
    //输出缓冲区分两种：固定大小和可变大小，固定大小为16KB，
    //可变大小最大不能超过服务器所设置的硬性限制值
    char buf[REDIS_REPLY_CHUNK_BYTES];
    int bufpos; //标志buf数组中使用长度
    list *reply;
}redisClient;
```

3. 客户端状态的fd属性记录了客户端正在使用的套接字描述符，fd属性的值可以是-1或者大于-1的整数
    * 伪客户端(fake client)的fd属性值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络。所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令
    * 普通客户端的fd属性值为大于-1的整数。

#### 客户端的创建
如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾


### 服务器
Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行所产生的数据，并通过资源管理来维持服务器自身的运转。

#### 命令请求的执行过程
1. 发送命令请求：Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器
2. 读取命令请求：当客户端和服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作:
    * 读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区中
    * 对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将其保存到argv和argc属性中
    * 调用命令执行器，执行客户端指定的命令
3. 命令执行
    * 第一件事就是根据客户端状态的argv[0]参数，在命令表(command table)中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面
    * 执行预备操作，各种检查。。
    * 调用命令的实现函数：在前面的操作中，服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和个数分别保存到了客户端状态argv和argc属性中，因为参数都已保存在状态里面了，所以当服务器决定执行命令时，它是需要执行以下语句

        ```cpp
        //client是指向客户端状态的指针
        client->cmd->proc(client);
        ```
    * 执行后续工作    
    * 将命令回复发送给客户端，客户端接收并打印命令回复
#### serverCron函数
Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转，其执行的主要操作如下：
1. 更新服务器时间缓存
2. 更新LRU时钟
3. 更新服务器每秒执行命令次数
4. 更新服务器内存峰值记录
5. 处理SIGTERM信号
6. 管理客户端资源
7. 管理数据库资源
8. 执行被延迟的BGREWRITEAOF
9. 检查持久化操作的运行状态
10. 将AOF缓冲区中的内容写入AOF文件
11. 关闭异步客户端
12. 增加cronloops计数器的值

#### 初始化服务器
一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器设置，创建相应的数据结构和网络连接等等。

1. 初始化服务器状态结构
    * 初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值
    
    ```cpp
    void initServerConfig(void){
        //设置服务器的运行id
        getRandomHexChars(server.runid, REDIS_RUN_ID_SIZE);
        
        //为运行id加上结尾字符
        server.runid[REDIS_RUN_ID_SIZE] = '\0';
        
        //设置默认配置文件路径
        server.configfile = NULL;
        
        //设置默认服务器频率
        server.hz = REDIS_DEFAULT_HZ;
        
        //设置服务器的运行架构
        server.arch_bits = (sizeof(long) == 8) ? 64 : 32;
        
        //设置默认服务器端口号
        server.port = REDIS_SERVERPORT;
        
        //...
    }    
    ```
2. 载入配置选项：服务器在用initServerConfig函数初始化完server变量之后，就会开始载入用户给定的配置参数和配置文件，并根据用户设定的配置，对server变量相关属性的值进行修改
3. 初始化服务器数据结构
4. 还原数据库状态
5. 执行事件循环




