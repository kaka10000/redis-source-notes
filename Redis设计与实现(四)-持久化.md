# Redis设计与实现(四):持久化

### RDB持久化
1. Redis是内存数据库，将自己的数据库状态储存咋内存里面，所以如果不想办法把储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。
2. RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。其所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件是的数据库状态。
3. RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件的存在，它就会自动载入RDB文件。
4. 因为AOF文件的更新频率比RDB文件的更新频率高，所以：
    * 如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件还原数据库状态
    * 只有在AOF持久化处于关闭时，服务器才会使用RDB文件来还原数据库状态
5. 当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件：

        save 900 1
        save 300 10
        save 60 10000
服务器会根据save选项所设置的保存条件，设置服务器状态redisServer结构的svaeparams属性

    ```cpp
    struct redisServer{
        //...
        //记录了保存条件的数组
        struct saveparam *saveparams;
        //修改计数器
        long long dirty;
        //上一次执行保存的时间
        time_t lastsave;
    };
    ```
* `saveparams`属性是一个数组，数组中的每个元素都是一个`saveparam`结构，每个`saveparam`结构都保存了一个save选项设置的保存条件：

    ```cpp
    struct saveparam{
        //秒数
        time_t seconds;
        //修改数
        int changes;
    };
    ```
* dirty计数器记录了距离上一次成功执行save或者bgsave命令之后，服务器对数据库状态进行了多少次修改(包括写入、删除、更新等操作)
* lastsave属性是一个unix时间戳，记录了服务器上一次成功执行save或者bgsave命令的时间

### RDB文件
1. 下表展示了一个完整RDB文件所包含的各个部分：

    <table>
    <tr>
    <td> REDIS </td>
    <td> db_version </td>
    <td> database </td>
    <td> EOF </td>
    <td> check_sum </td>
    </tr>
    </table>
    
* RDB文件的最开头是REDIS部分，长度5字节，保存着"REDIS"这五个字符，通过这五个字符，程序在载入文件时，快速检查所载入的文件是否是RDB文件
* db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号
* database部分包含零个或任意多个数据库，以及各个数据库中的键值对数据：
    * 如果服务器的数据库状态为空(所有数据库都是空的)，那么这部分也为空，长度为0字节
    * 如果服务器的数据库状态非空(有至少一个数据库非空)，那么这部分也非空，根据数据所保存的键值对的数量、类型和内容不同，这部分的长度也会有所不同
* EOF为1字节，标志RDB文件正文内容的结束
* check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是根据前面四个部分计算得到的。
2. 一个RDB文件的database部分可以保存任意多个非空数据库，比如：

    <table>
    <tr>
    <td> REDIS </td>
    <td> db_version </td>
    <td> database 0 </td>
     <td> database 3 </td>
    <td> EOF </td>
    <td> check_sum </td>
    </tr>
    </table>

### AOF持久化
1. 除了RDB持久化之外，Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的
2. AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤。
* 命令追加：当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾：

    ```cpp
    struct redisServer{
        //...
        //AOF缓冲区
        sds aof_buf;
    };
    ```
* Redis的服务器进程就是一个事件循环(loop)，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行需要定时运行的函数。因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。伪代码如下：

    ```python
    def eventLoop():
        while True:
            # 处理文件事件，接收命令请求以及发送命令回复
            # 处理命令请求时可能会有新内容被追加到aof_buf缓冲区中
            processFileEvents()
            
            #处理时间事件
            processTimeEvents()
            
            #考虑是否要将aof_buf中的内容写入和保存到AOF文件里面
            flushAppendOnlyFile()
    ```
3. Redis读取AOF文件并还原数据库状态的详细步骤如下：
    * 1) 创建一个不带网络连接的伪客户端(fake client)：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件所保存的写命令，伪客户端执行命令的效果和带有网络连接的客户端执行命令的效果完全一样
    * 2) 从AOF文件中分析并读取出一条写命令
    * 3) 使用伪客户端执行被读出的写命令
    * 4) 一直执行步骤2和步骤3，知道AOF文件中的所有写命令被处理完为止
4. 因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，随着服务器运行时间的流逝，AOF文件内容越来越多。为了解决AOF文件体积膨胀问题，Redis提供了AOF文件重写功能。通过该功能，Redis可以创建一个新AOF文件来替代现有的AOF文件，两个文件保存的数据库状态相同，但是新AOF文件不会包含任何浪费空间的冗余命令。
5. 虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为AOF文件重写，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或写入操作，而是通过读取服务器当前的数据库状态来实现的。